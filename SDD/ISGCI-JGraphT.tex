% !TEX encoding = UTF-8 Unicode
% Vorlage zur Generierung von Uebungsloesungsblaettern.

\documentclass[10pt,a4paper]{article}
\usepackage{algorithm2e}
\usepackage{vorlage}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}  % Für z.B. Mengenzeichen
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\usepackage{graphics} 
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{courier}
\usepackage{textcomp}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{color}
\usepackage[ngerman]{babel}



\begin{document}

\subsection{ISGCI-Package JGraphT}

\textbf{Allgemein:}
JGraphT wird benötigt, um die Graph-Struktur zu verwalten und Funktionen darauf auszuführen. Der Schwerpunkt liegt auf Funktionen zur logischen Reduzierung des Graphen und Filterung bestimmter Zusammenhänge (Nachbarn bestimmen etc.). Daneben werden noch nützliche Algorithmen zur Verarbeitung von Graphen bereitgestellt (z.B. Walkers).\\




\textbf{Annotation.java}\\
Zuständig für Informationen(Kommentare/Anmerkungen), die an Knoten oder Kanten angehängt werden (Benutzt z.B. von Walkern zur Markierung bereits besuchter Knoten).\\
Verschiedene Funktionen ermöglichen, in einem Annotation-Objekt bestimmten Knoten/Kanten Informationen (Data) zuzuordnen und auzulesen.\\

\textbf{AsWeightedDirectedGraph.java}\\
\textit{Erweitert AsWeightedGraph und implementiert DirectedGraph}\\
Notwendig zur Darstellung des Graphen als gewichteter, gerichteter Graph.\\
Mithilfe dieser Klasse können Algorithmen, die für ungewichtete Graphen ausgelegt sind auch auf gewichtete angewendet werden (Mapping von Kanten und Gewichten).\\

\textbf{BFSWalker.java}\\
\textit{Erweiterung von GraphWalker}\\
Beinhaltet BFS Algorithmus. Durchläuft einen Graphen, ausgehend von einem gegebenen Startknoten (benutzt nur Kanten).\\
Umsetzung: Alle Knoten kommen in eine Warteschlange, werden nach und nach (via. BFS) besucht und aus der Queue gelöscht.\\

\textbf{DFSWalker.java}\\
\textit{Erweiterung von GraphWalker}\\
Beinhaltet DFS Algorithmus. Durchläuft alle Knoten eines Graphen, ausgehend von einem gegebenen Startknoten.\\
Umsetzung: Über ein Annotation-Objekt können besuchte Knoten markiert werden. Durchlauf mittels DFS Algorithmus.\\

\textbf{GraphWalker.java}\\
\textit{Abstrakte Klasse}\\
GraphWalkers werden benötigt, um einen Graphen zu durchlaufen - vgl. BFSWalker/DFSWalker. \\

\textbf{CacheGraph.java}\\
\textit{Erweiterung von ListenableDirectedGraph}\\
Ermöglicht die Erstellung eines gerichteten Graphen mit cashing von Kanten und Knoten.\\
Umsetzung: HashMaps jeweils für Knoten und Kanten.\\
Überschreibt verschiedene Methoden/stellt zur Verfügung: Suchen von Knoten/Kanten, Feststellung ob Knoten/Kanten vorhanden sind und Konsistenz-Checks.\\

\textbf{ClosingDFS.java}\\
\textit{Erweiterung von DFSWalker}\\
Definition von Closed Graph: In a directed graph G = (V, A), a set S of vertices is said to be closed if every successor of every vertex in S is also in S. Equivalently, S is closed if it has no outgoing edge.\\
Beinhaltet DFS Algorithmus zur rekursiven Bestimmung der transitiven Abgeschlossenheit eines Graphen (Menge an Knoten/Kanten, so dass der Graph abgeschlossen ist).\\

\textbf{Deducer.java}\\
Stellt einen Algorithmus zur Entfernung aller trivialen Inklusionen in einem Graphen zur \\Verfügung.\\
Beinhaltet verschiedene Funktionen: Statistik - Auskunft über Relationen, Inklusionen und deren Beschaffenheiten; Suche und Entfernung Trivialer Inklusionen (Umformungen, teilweise Umstrukturierung des Graphen)\\

\textbf{GAlg.java}\\
Beinhaltet verschiedene Algorithmen und andere Funktionen für Graphen.\\
Funktionen: Teilen des Graphen in Zusammenhangskomponenten; Selektion aller Nachbarn eines Knoten; Bestimmung eines Pfades zwischen zwei Knoten; Angabe der Topologischen Ordnung eines Graphen(falls möglich); Transitive Reduzierung des Graphen.\\













\end{document}
