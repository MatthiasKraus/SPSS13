% !TEX encoding = UTF-8 Unicode
% Vorlage zur Generierung von Uebungsloesungsblaettern.

\documentclass[10pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage{algorithm2e}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}  % Für z.B. Mengenzeichen
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\usepackage{graphics} 
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{courier}
\usepackage{textcomp}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{color}




\begin{document}


\section{Funktionen des bestehenden Systems}
Beschreibung der aus dem GUI ableitbaren Funktionen
\subsection{File}
\subsection{View}
\emph{View stellt beim Klicken auf den Menüreiter "`View"'\ in der Navigationsleiste verschiedene Funktionen zur Optimierung der Ansicht zur Verfügung. Darunter fällt das Suchen nach einer Graphklasse, die Einstellung der Namensanzeige und das Markieren von "`unproper"' (müsste eigentlich improper heißen) inclusions.}\\

\paragraph{Search in drawing...}\ \\
Beim Auswählen des Punktes "`search in drawing"' durch einen linken Mausklick, öffnet sich das Fenster "`Search for a graphclass"'. Aus einer Liste kann in diesem Feld eine Graphklasse, aus allen Graphklassen ausgewählt werden und durch das Drücken von Search gesucht werden. Dabei wird stets nur die Graphklassen angezeigt, die im Drawing auffindbar sind. Durch "`cancel"' kann der Suchvorgang abgebrochen werden. Sucht man durch Drücken auf "`search"' nach einer aus der Liste gewählten Klasse, dann wird der Canvas so verschoben, dass die Graphklasse sichtbar ist.


\paragraph{Naming preference...}\ \\
Beim Auswählen des Punktes "`Naming preference.."', durch einen linken Mausklick, öffnet sich das Fenster "`Naming preference"'. Dieses stellt drei Möglichkeiten durch Radio-Buttons zur Auswahl. Dabei kann immer nur ein Radio-Button aktiv sein. (Eigenschaft der Radio-Buttons) \\
\begin{itemize}
	\item[\bf{Basic}] e.g. threshold
	\item[\bf{Forbidden subgraphs}] e.g. ($P_4,2K_2,C_4$)-free
	\item[\bf{Derived}] e.g. cograph $\cap$ split\\
\end{itemize}
Das Auswählen einer dieser drei Optionen und das bestätigen durch "`OK"', hat eine Umbenennung aller Nodes im Drawing zur angegebenen Konvention zur Folge.

\paragraph{Mark unproper(improper) inclusions}\ \\
Beim Auswählen des Punktes "`Mark unproper inclusions"', durch einen linken Mausklick, wird dieser Menüpunkt mittels eines ein- / ausblendbaren Häkchen als aktiv / inaktiv gekennzeichnet. Wird dieser Menüpunkt als aktiv gekennzeichnet, so werden alle "`unproper inclusions"' durch verblasste (geringere Opacity, Grauwert anstelle von Schwarz) Pfeile an einer Edge dargestellt. Wobei der Pfeil auf die Graphklasse mit unproper inclusions zeigt. Beim Deaktivieren dieser Funktion verschwindet dieser graue Pfeil.


\subsection{Graph classes}
\emph{Der Reiter "`Graph classes"' in der Menüleiste stellt verschiedene Funktionen zum Finden von Klassen anhand derer Eigenschaften und Browsen durch die Graph-Klassen-Datenbank zur Verfügung, die im Folgenden näher erläutert werden.}
Bevor folgende Schritte getan werden können, muss der bereits genannte Reiter per Mausklick (egal ob rechts oder links) ausgewählt(geöffnet) werden.\\
Ein wichtiger Punkt ist, dass egal welche Fenster geöffnet sind, der Benutzer in keinem Fenster blockiert wird, auch wenn er über dieses bereits ein anderes geöffnet hat, dabei bleiben diese im Vordergrund, wenn das Hauptfenster angewählt wird. Dies ist für den Benutzer sehr hilfreich, da er sich keine Informationen zur aktuellen Einstellung (z.B. im "`Browse Database"') merken muss und kurzzeitig nach etwas anderem schauen kann.
\paragraph{Browse Database}\ \\
Durch Klicken auf die Auswahlmöglichkeit "`Browse Database"' öffnet sich das Fenster "`Graph Class Information"'. Nun hat man die Möglichkeit Graph-Klassen anzuwählen, um über diese Informationen zur Komplexität der Probleme zu Graphklassen zu erhalten (Eine Tabelle mit 2 Spalten: Problem und Complexity; nicht alphabetisch geordnet). Außerdem steht ein Filter zu Verfügung, mit dem man durch Eingeben des Namens oder nur ein Teil davon, dabei ist egal, an welcher Stelle er im Namen der Graph-Klasse steht, die Informationen zu Klassen, welche die Eingabe beinhalten, angezeigt bekommt.\\
Zu diesen Informationen gehören allerdings nicht nur die Komplexität von Problemen. Unter der bereits genannten Tabelle sind 3 weitere, nebeneinanderstehende Listen mit gleicher Breite angeordnet. Diese Listen beinhalten (von links nach rechts erklärt) alle Superklassen, Äquivalenzklassen und Subklassen (zur in der ersten Liste ausgewählten Graphklasse). Durch Verändern der Breite und Höhe des Fensters verändert sich dynamisch die Größe der Listen. Während sich bei der Tabelle nur die Breite verändert, da diese eine feste Anzahl an Zeilen hat, verändert sich die Höhe der Listen ebenfalls relativ zur Fenstergröße. Die Breite der "`Graph Class"'-Liste erstreckt sich über die Breite des gesamten Fensters(entsprechend der 3 Listen im unteren Teil zusammen). In jeder Liste sind die Klassen alphabetisch angeordnet (Groß- vor Kleinbuchstaben; Sonderzeichen werden ignoriert), sodass man seine gewünschte Graph-Klasse auch darüber filtern kann. Wichtig ist, dass in jeder der 4 Listen, in denen die aktuellen Graph-Klassen bezüglich ihrer Eigenschaft zur Auswahl, angewählt werden können, sodass man sich durch die Zusammenhänge der Klassen "`klicken"' kann. Zu beachten ist, dass durch einfaches Anwählen die Klassen in den unteren 3 Listen nur markiert werden und erst deren Informationen nach einem Doppelklick(Linksklick) angezeigt werden, während man durch einfaches Anwählen einer Klasse in der oberen Liste, sofort dessen Informationen zu entsprechenden Problemen erhält (ohne Doppelklick).\\
Ganz unten im Fenster werden zentriert verschiedene Buttons angezeigt:
\begin{itemize}
\item[Class details:] Ist der 1. Button (von links). Durch einfachen Linksklick wird die entsprechende Detail-Seite im Standard-Browser geöffnet und zeigt ausführlichere Informationen zur aktuell ausgewählten Graph Klasse der oberen Liste im Fenster. Dazu gehören "`References, Related classes, Inclusions, Problems(alphabetisch geordnet)"'
\item[Inclusion info:] Ein Linksklick auf diesen Button (2.) öffnet ein weiteres (kleines) Fenster("`Relation"'), welches Informationen zu Inklusionen zu anderen Graphklassen anzeigt. Im unteren Teil dieses Fensters befinden sich 3 Buttons:
\begin{itemize}
\item View references: öffnet eine Seite im Standard-Browser mit Referenzen auf Literatur bezüglich der angegebenen Inklusion(en) ("`Relation"').
\item Draw: Zeichnet im Hauptfenster("`ISGCI"') einen Graphen inklusiv der Inklusionen zu den aktuell im Relation-Fenster angezeigten Inklusion.
\item OK: Einfacher Button, dessen Betätigung zur Schließung des Relation-Fensters führt.
\end{itemize}
\item[Draw:] Durch Betätigung dieses Buttons(3.) wird ein weiteres Fenster ("`Select Graph Classes"') geöffnet, welches wie im vorigen einen analogen Filter zur Limitierung der angezeigten Klassen in der darunter befindlichen Liste hervorruft. In diesem Fenster steht im Gegensatz zum vorigen Fenster ("`Graph Class Information"') nur eine Liste, welche als Standard-Auswahl immer die Graph-Klasse des vorigen Fensters ausgewählt hat, damit der Benutzer nicht erneut die Klasse suchen muss, welche er im Hauptfentser ("`ISGCI"') anzeigen möchte. Der Benutzer hat zusätzlich über zwei Checkboxen, die sich unter der Liste befinden, die Möglichkeit, zu der ausgewählten Graph-Klasse auch deren Super- bzw. Subklasse durch Aktivieren der Checkboxen für die jeweiligen Klassen mit in dem zu zeichnenden Graphen anzuzeigen. \\ Im unteren Teil dieses Fenster befinden sich der Button "`New drawing"' über den der Benutzer seine Auswahl bestätigen kann, sich das Fenster schließt und im Hauptfenster das Ergebnis (den gezeichneten Graphen mit/ohne seine Super-/Subklassen) betrachten kann. Rechts neben dem eben genannten Button befindet sich ein "`Cancel"'-Button, welcher das Fenster schließt, ohne dass sonst etwas im Programm geschieht und der Benutzer wird zu dem Fenster zurückgeführt, von dem aus er dieses geöffnet hat ("`Graph Class Information"').
\item[Close:] Wenn der User diesen Button (ganz rechts; 4.) klickt (Linksklick), wird das Fenster "`Graph Class Information"' geschlossen und der Benutzer gelangt zum Hauptfenster "`ISGCI"' zurück, in dem die letzte ausgewählte Zeichnung noch angezeigt wird.
\end{itemize}
\paragraph{Find Relation...} \ \\
Über diesen Auswahlpunkt öffnet sich durch Klicken (rechts/links) das Fenster "`Find Relation"'. In diesem hat der Benutzer die Möglichkeit über 2 untereinander dargestellte Listen, welche alle Graph-Klassen beinhalten, oder über einen Filter (je Liste), zwei Graph-Klassen anzuwählen und sich über einen darunter befindlichen Button "`Find Relation"' deren Verbindung anzusehen. Die Filter Funktion ist dabei analog zu der Filter-Funktion in dem Auswahlpunkt "`Browse Database"' umgesetzt. Nach Betätigung des eben genannten "`Find relation"' Buttons öffnet sich ein weiteres Fenster, welches nun Informationen zur Relation der angewählten Klassen anzeigt (wird im links oben auf dem Bildschirm geöffnet). Die anzeigten Verbindungen der beiden Klassen werden begründet, in welchem Zusammenhang sie stehen und nicht nur dass sie es tun ("`by definition, forbidden subgraphs ..."'). Dabei zu beachten ist, dass sich die Größe des Fenster an der Menge des zu anzeigenden Textes orientiert, sodass das Fenster möglich wenig Platz auf dem Bildschirm einnimmt. Zusätzlich zu diesen Relation-Informationen kann man über den Button "`View references"' (links unten im Fenster) Referenzen zu Literatur über die graphclasses.org - Homepage anzeigen lassen, über einen weiteren Button (rechts von "`View references"') kann der Benutzer diese Relation im Hauptfenster zeichnen lassen (mit dazwischenliegenden Klassen), analog zur "`Draw"'-Funktion des bereits erklärten Auswahlpunktes. Ein dritter Button "`OK"' (rechts von "`Draw"') führt (ebenfalls analog) zur Schließung des "`Relation"' Fensters und der Benutzer kommt zum "`Parent-Fenster"' zurück.\\
Rechts neben dem Button "`Find relation"' befindet sich der Button "`Close"' (beide ganz unten im Fenster horizontal zentriert), der ebenfalls analog zur schon bereits genannten Funktion dieses Fenster schließt und zum Hauptfenster zurückgelangt.

\paragraph{Draw...}\ \\
Dieser letzte Auswahlpunkt im Reiter "`Graph classes"' der Menüleiste führt zu dem exakt identischen Fenster, wie beim Klicken des "`Draw"' Buttons über den Auswahlpunkt "`Browse Database"' (nur eben nicht über diesen Umweg), falls der Benutzer schon weiß, welche Klassen er gezeichnet bekommen möchte. Dieses Fenster hat den selben Namen "`Select Graph Classes"' und beinhaltet ebenso einen Filter und eine Liste zu allen Graph-Klassen, in dem die gewünschte Klassen angewählt und mit/ohne deren Super-/Subklassen gezeichnet werden kann. Mit der Bestätigung über den Button "`New drawing"' schließt sich das Fenster und die Auswahl wird in dem Hauptfenster graphisch dargestellt.



\subsection{Problems}
\subsection{Help}
\subsection{Rechtsklick auf gezeichneten Knoten}
\subsection{Information Fenster}

\section{wichtige Klassen des bestehenden Systems}
\subsection{ISGCI-Package JGraphT}

\paragraph{Allgemein:}\ \\
JGraphT wird benötigt, um die Graph-Struktur zu verwalten und Funktionen darauf auszuführen. Der Schwerpunkt liegt auf Funktionen zur logischen Reduzierung des Graphen und Filterung bestimmter Zusammenhänge (Nachbarn bestimmen etc.). Daneben werden noch nützliche Algorithmen zur Verarbeitung von Graphen bereitgestellt (z.B. Walkers).\\


\paragraph{Annotation.java}\ \\
Zuständig für Informationen(Kommentare/Anmerkungen), die an Knoten oder Kanten angehängt werden (Benutzt z.B. von Walkern zur Markierung bereits besuchter Knoten).\\
Verschiedene Funktionen ermöglichen in einem Annotation-Objekt bestimmten Knoten/Kanten Informationen (Data) zuzuordnen und auszulesen.\\

\paragraph{AsWeightedDirectedGraph.java}\ \\
\emph{Erweitert AsWeightedGraph und implementiert DirectedGraph}\\
Notwendig zur gewichteten und gerichteten Darstellung des Graphen.\\
Mithilfe dieser Klasse können Algorithmen, die für ungewichtete Graphen ausgelegt sind auch auf gewichtete angewendet werden (Mapping von Kanten und Gewichten).\\

\paragraph{BFSWalker.java}\ \\
\emph{Erweiterung von GraphWalker}\\
Beinhaltet BFS Algorithmus. Durchläuft einen Graphen, ausgehend von einem gegebenen Startknoten (benutzt nur Kanten).\\
Umsetzung: Alle Knoten kommen in eine Warteschlange, werden nach und nach (via. BFS) besucht und aus der Queue gelöscht.\\

\paragraph{DFSWalker.java}\ \\
\emph{Erweiterung von GraphWalker}\\
Beinhaltet DFS Algorithmus. Durchläuft alle Knoten eines Graphen, ausgehend von einem gegebenen Startknoten.\\
Umsetzung: Über ein Annotation-Objekt können besuchte Knoten markiert werden. Durchlauf mittels DFS Algorithmus.\\

\paragraph{GraphWalker.java}\ \\
\emph{Abstrakte Klasse}\\
GraphWalkers werden benötigt, um einen Graphen zu durchlaufen - vgl. BFSWalker/DFSWalker. \\

\paragraph{CacheGraph.java}\ \\
\emph{Erweiterung von ListenableDirectedGraph}\\
Ermöglicht die Erstellung eines gerichteten Graphen mit cashing von Kanten und Knoten.\\
Umsetzung: HashMaps jeweils für Knoten und Kanten.\\
Überschreibt verschiedene Methoden/stellt zur Verfügung: Suchen von Knoten/Kanten, Feststellung ob Knoten/Kanten vorhanden sind und Konsistenz-Checks.\\

\paragraph{ClosingDFS.java}\ \\
\emph{Erweiterung von DFSWalker}\\
Definition von Closed Graph: "`In a directed graph G = (V, A), a set S of vertices is said to be closed if every successor of every vertex in S is also in S. Equivalently, S is closed if it has no outgoing edge"'.\\
Beinhaltet DFS Algorithmus zur rekursiven Bestimmung der transitiven Abgeschlossenheit eines Graphen (Menge an Knoten/Kanten, so dass der Graph abgeschlossen ist).\\

\paragraph{Deducer.java}\ \\
Stellt einen Algorithmus zur Entfernung aller trivialen Inklusionen in einem Graphen zur \\Verfügung.\\
Beinhaltet verschiedene Funktionen: Statistik - Auskunft über Relationen, Inklusionen und deren Beschaffenheiten; Suche und Entfernung trivialer Inklusionen (Umformungen, teilweise Umstrukturierung des Graphen)\\

\paragraph{GAlg.java}\ \\
Beinhaltet verschiedene Algorithmen und andere Funktionen für Graphen.\\
Funktionen: Teilen des Graphen in Zusammenhangskomponenten; Selektion aller Nachbarn eines Knoten; Bestimmung eines Pfades zwischen zwei Knoten; Angabe der topologischen Ordnung eines Graphen(falls möglich); Transitive Reduzierung des Graphen.\\

\paragraph{Inclusion.java}\ \\
\emph{extends org.jgrapht.graph.DefaultEdge
        implements Relation}\\
Diese Klasse hält die Informationen einer Kante, nämlich Super- und Subklasse und ob es sich um eine unklare Inklusion handelt oder nicht.\\
\paragraph{ISGCIVertexFactory.java}\ \\
\emph{ implements VertexFactory<Set<GraphClass> >}\\
Klasse um virtuelle Knoten zu erstellen.\\
\paragraph{RevBFSWalker.java}\ \\
\emph{extends BFSWalker<V,E>}\\
Durchläuft einen Graphen mittels gerichteter Breitensuche.\
\paragraph{TreeBFSWalker.java}\ \\
\emph{ extends UBFSWalker<V,E>}\\
Durchläuft den Spannbaum eines Graphen mittels ungerichteter Breitensuche. Anmerkung: Markiert nicht selbstständig den Spannbaum.\\
\paragraph{TreeDFSWalker.java}\ \\
\emph{extends UDFSWalker<V,E>}\\
Durchläuft die Knoten des Spannbaums eines Graphen mittels ungerichteter Tiefensuche.\\
\paragraph{UBFSWalker.java}\ \\
\emph{ extends BFSWalker<V,E>}\\
Durchläuft den Graphen mit einer ungerichteten Breitensuche.\\
\paragraph{UDFSWalker.java}\ \\
\emph{extends DFSWalker<V,E>}\\
Durchläuft den Graphen mit einer ungerichteten Tiefensuche.\\
\paragraph{WalkerInfo.java}\ \\
\emph{}\\
Diese Klasse wird benutzt um Knoten Informationen zu geben, während der Graph mittels Tiefen- oder Breitensuche durchlaufen wird.

\subsection{ISGCI-Package Layout}

Alle Klassen, die in dem \texttt{./layout}-Ordner stehen sind für das Layout des letztendlich zu zeichnenden Graphen zuständig, dabei stehen diese stark mit den Klassen aus dem \texttt{./grapht}-Ordner in Zusammenhang. Die ganzen Klassen und deren Methoden werden über die Klassen des \texttt{./gui}-Ordners aufgerufen.

Im Folgenden werden alle Klassen aus dem \texttt{./layout} grob beschrieben und deren Funktionweise und Zuständigkeit näher erläutert. Konkrete Details, wie Methodendeklarationen, Methodenaufrufe und Variablen werden spärlich erläutert. Dies sollte aber der oberflächenden Verständlichkeit nicht im Wege stehen, wenn nicht sogar dienen.

\paragraph{GraphDrawInfo.java}\ \\
\emph{Erweiterung von WalkerInfo.java}\\
{\footnotesize Diese Klasse erweitert die Klasse \texttt{WalkerInfo.java} aus dem Package \texttt{./grapht}, welche dafür zuständig ist, ob Kanten zu einem zu berechnenden/anzuzeigenden Graphen gehört oder nicht. Bei Knoten wird auf Adjazenz geprüft (näheres in der Beschreibung bei \texttt{grapht}), ob der Knoten zum dem zu zeichnenden Graphen gehört. Sie fügt weitere Variablen, die Werte für Knoten und Kanten, die zur Graphzeichnung benötigt werden, beinhalten. Dazugehören auch virtuelle Knoten, die keinen Inhalt haben und nur zur Kantenzeichnung benötigt werden. Außerdem werden Variablen zur Ranking-Berechnung deklariert, um die spätere richtige Position in der Zeichnung zu bestimmen. Alle benötigten Variablen werden im Konstruktor mit Default-Werten instanziiert und überschrieben, sobald diese benötigt werden. (i.e. Breite des Knotens, Koordinaten, Position im Ranking usw.)}

\paragraph{HierachyLayout.java}\ \\
{\footnotesize Diese Klasse ist zur Berechnung der Hierarchie im Layout zuständig. Jedoch muss berücksichtigt werden, dass eine konsistente Hierarchie nur erreicht werden kann, wenn der Graph, zu dem die Hierarchie berechnet werden soll, ein gerichteter nicht-zyklischer Graph ist. Es muss beachtet werden, dass dieser transitiv reduziert ist. Erneut spielt die Berechnung des Rankings und der virtuellen Knoten eine entscheidende Rolle, wobei diese Berechnungen mit JGraphT stattfinden. Dazu gehört die Beschreibung des zum Knoten gehörenden Vertex (Weite, Rank..). Um das Layout der Hierarchie zu berechnen, wird die eben beschrieben Klasse \texttt{GraphDrawInfo.java} verwendet. Bei der Berechnung werden dabei die 4 Prinzipien berücksichtigt, die in der Dokumentation zur Zeichnung (\texttt{./doc/1993drawing.pdf}) näher erläutert und bei den 3 Durchläufen des "`Network Simplex Algorithm"' beachtet werden. Der konkrete Ablauf, welche Schritte getan werden müssen, werden dort näher erläutert. (Machbarkeitsbaumberechnung mit entsprechendem Ranking der den length-constraints genügen muss).  Es werden verschiedene Algorithmen ausgeführt, welche mit einigen Hilfsmethoden u.a. Spannbäume mit festen Kanten, machbare Rankings berechnet [...]. Hierbei muss flüchtig erwähnt werden, dass die Berechnung in den Grundzügen auf Ersetzung von Graphkanten und -knoten durch Nichtgraphkanten und -knoten, um die Machbarkeit mit einem optimalem Ranking zu erreichen, basiert. Es wird versucht ein minimalen Graphen zu finden (optimales Ranking) der den 4 Prinzipien nachkommt. Dabei werden die Variablen der Klasse \texttt{GraphDrawInfo.java} benötigt.} 

\paragraph{LLWalker.java}\ \\
\emph{Erweiterung von TreeDFSWalker.java}\\
{\footnotesize Traversiert die Knoten eines Baumes mithilfe von Tiefensuche, indem die Methoden der Oberklasse verwendet werden.}

\paragraph{Ranks.java}\ \\
{\footnotesize In dieser Klasse werden die Knoten eines Graphen über Rankings verwaltet. Einer der Hauptaspekte für die Verwendung von Rankings ist, dass die Kantenkreuzungen soweit wie möglich minimiert werden. Ein initiales Ranking wird durch Zuweisung eines Rankings für jeden über Breitensuche (durch Traversierung), wobei bei dem niedrigsten Ranking begonnen wird (in der Anwendung von oben nach unten), erstellt. Das ist notwendig, um sicherzugehen, dass dieses Ranking ein Baum ohne Kantenkreuzungen ist. Um dies zu erreichen wird \texttt{HierarchyLayout.java} verwendet, indem über sie virtuelle Knoten erstellt und gesetzt werden, um ein optimales Ranking für die Kantenkreuzungen zu erreichen. Um die Knoten innerhalb eines Rankings effektiv zu sortieren werden Heuristiken (siehe \texttt{./doc/1993drawing.pdf}) verwendet (z.B. Median, Barycenter, Minimum, Sifting..). Es werden iterative heuristische Berechnungen entsprechend der bereits genannten Dokumentation ausgeführt, um ein bestmögliches in einem akzeptablen Rahmen des Berechnung-Aufwandes Ergebnis zu erzielen (Vertauschung von Knoten, falls dadurch Kreuzungen vermieden werden).}

\paragraph{TightTreeWalker.java}\ \\
\textit{Erweiterung von UBFSWalker.java;\\ wird in} {\small \texttt{HierarchyLayout.java}} \textit{für den "`Network Simplex Algorithm"'\ verwendet}\\
{\footnotesize Diese Klasse wird benötigt um einen gerichteten Graphen mithilfe von Breitensuche \textit{ungerichtet} zu traversieren, dabei werden nur Kanten, die fest("`tight"'$\overset{\wedge}{=}$ slack = 0) sind, berücksichtigt. \\
Es wird ein Startknoten definiert, mit dem diese Traversierung ausgeführt wird. Die zu traversierenden Kanten sind als Baumkanten markiert (Information aus \texttt{GraphDrawInfo.java}). Als Ergebnis erhält man einen Spannbaum für den Eingabe-Graphen.}

\paragraph{TreeReranker.java}\ \\
\emph{Erweiterung von TreeBFSWalker}\\
{\footnotesize Mithilfe dieser Klasse werden neue Rankings auf einem Layout-Graphen (als Baum übergeben) erstellt, um ein optimales Ranking zu erhalten (durch Breitensuche). Sie wird eigentlich nur verwendet, um eine semantische Trennung zum \texttt{TreeBFSWalker.java} zu erhalten, denn jede verwendete Methode ruft eine entsprechende Methode aus der Oberklasse auf.}


\subsection{ISGCI-Package db}
Hier liegen viele Algorithmen; z.B. beinhaltet die Klasse Algo.java Algorithmen um Subklassen/Superklassen eines Knoten zu finden und diese auszugeben. Diese werden benötigt um die Inklusionsinformationen zu speichern und abzurufen.\\

\subsection{ISGCI-Package gc}
GC steht für GraphClass. In diesem Package sind alle GraphClass Klassen enthalten. Jede enthaltene Java Klasse beschreibt eine GraphClass und deren besondere Eigenschaften.\\

\subsection{ISGCI-Package iq}
Hier finden ISGCI Queries statt. db und gc nutzen dieses Package um Queries auszuführen. \\

\subsection{ISGCI-Package problem}
Store complexity information for graph problems, in diesem Package sind alle Funktionen enthalten, die dazu genutzt werden ein Problem zu beschreiben.\\

\subsection{ISGCI-Package util}
In dem util Package liegen alle für spezielle Funktionalitäten benötigte Klassen. Dazu gehört eine Reihe von Klassen, die die Verwendung von "`LaTeX"' innerhalb des ISGCI ermöglicht (d.h. das Verwenden einiger LaTeX-Symbole).\\


\subsection{ISGCI-Package xml}
Das Package xml ist zum Input/Output von XML Dateien; hier werden Informationen aus XML Dateien gelesen und ausgegeben. Das Package xml greift dabei auf das Package sax zu und nutzt deren Filterfunktionalität. Die Daten aus einem XML input/output werden den Klassen Grapht, ISG und Util zur Verfügung gestellt. \\

\subsection{ISGCI-Package isq}
In isq werden die Graph Familien, Zusammenhänge aus einer XML gelesen und zum Zeichnen vorbereitet, also an JGraphT weitergereicht. Dabei nutzt isq Funktionen des util Packages. 

\subsection{ISGCI-Package sax}
Das Package sax beinhaltet nur die Klasse XMLWriter.java. Diese ist ein Filter um ein XML Dokument aus einem SAX (Simple API for XML) event stream zu erzeugen. Diese Klasse wird vom XML Parser benötigt.






\end{document}
